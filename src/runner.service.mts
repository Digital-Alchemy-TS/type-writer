import { is, TServiceParams } from "@digital-alchemy/core";
import { existsSync, mkdirSync, rmSync, writeFileSync } from "fs";
import { isAbsolute, join } from "path";
import { cwd, exit } from "process";

const HEADER = [
  "// This file is generated by type-writer",
  "// Changes will not be preserved if you run the command again",
  "",
].join("\n");
const REGISTRY_HEADER = [
  HEADER,
  `// Missing attributes?`,
  `// https://docs.digital-alchemy.app/docs/home-automation/type-writer/custom-attributes`,
  "",
].join("\n");

export function Runner({ type_build, lifecycle, logger, config, hass, context }: TServiceParams) {
  async function runner() {
    try {
      const writeBase = isAbsolute(config.type_writer.TARGET_DIR)
        ? config.type_writer.TARGET_DIR
        : join(cwd(), config.type_writer.TARGET_DIR);
      if (existsSync(writeBase)) {
        logger.info(`rm -r {%s}`, writeBase);
        rmSync(writeBase, { recursive: true });
      }
      mkdirSync(writeBase);

      const { services, registry, mappings } = await type_build.build();

      if (!is.empty(writeBase)) {
        writeFileSync(join(writeBase, `mappings.mts`), HEADER + mappings, "utf8");
        writeFileSync(join(writeBase, `services.mts`), HEADER + services, "utf8");
        writeFileSync(join(writeBase, `registry.mts`), REGISTRY_HEADER + registry, "utf8");
      }
      logger.warn({ base: writeBase }, `successfully wrote type definitions file`);
      logger.info(`{reload your editor to update types}`);
    } catch (error) {
      logger.fatal({ error }, `failed to write type definitions file`);
    }
  }

  lifecycle.onReady(async () => {
    logger.debug(`starting build`);
    await runner();
    const watch = config.type_writer.WATCH_MODE;
    if (watch) {
      logger.info(`Watching Home Assistant for updates...`);
      const onUpdate = async () => {
        logger.info(`Update received in Home Assistant. Writing new types...`);
        await runner();
      };

      hass.socket.onEvent({ context, event: "service_registered", exec: onUpdate });
      hass.socket.onEvent({ context, event: "service_removed", exec: onUpdate });
      hass.events.onAreaRegistryUpdate(onUpdate);
      hass.events.onDeviceRegistryUpdate(onUpdate);
      hass.events.onEntityRegistryUpdate(onUpdate);
      hass.events.onFloorRegistryUpdate(onUpdate);
      hass.events.onLabelRegistryUpdate(onUpdate);
      hass.events.onZoneRegistryUpdate(onUpdate);
    } else {
      setImmediate(() => exit());
    }
  }, Number.NEGATIVE_INFINITY);
}
