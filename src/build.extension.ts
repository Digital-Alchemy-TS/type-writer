import { is, TServiceParams } from "@digital-alchemy/core";
import { existsSync, writeFileSync } from "fs";
import { dirname, join } from "path";
import { exit } from "process";
import { fileURLToPath } from "url";

const PICK_FROM_PLATFORM = `type PICK_FROM_PLATFORM<
  ID extends TPlatformId,
  DOMAIN extends TRawDomains = TRawDomains,
> = Extract<REGISTRY_SETUP["platform"][\`_\${ID}\`], PICK_ENTITY<DOMAIN>>;`;

export function BuildTypes({ logger, hass, type_build, config, internal }: TServiceParams) {
  async function runner() {
    try {
      // install location
      // node_modules/@digital-alchemy/type-writer/dist/index.js
      //
      // relative target file
      // ../../hass/dist/dynamic.d.ts
      //
      const path = is.empty(config.type_build.TARGET_FILE)
        ? join(dirname(fileURLToPath(import.meta.url)), "..", "..", "hass", "dist", "dynamic.d.ts")
        : config.type_build.TARGET_FILE;
      if (!existsSync(path)) {
        if (config.type_build.TARGET_FILE !== path) {
          // Represents an error with the script
          // Calculated the wrong path, and something is up
          logger.fatal({ path }, `cannot locate target file, aborting`);
          return;
        }
        logger.warn({ path }, `creating new type definitions file`);
      }
      const text = await doBuild();
      writeFileSync(path, text);
      logger.warn({ path }, `successfully wrote type definitions file`);
      logger.info(`{reload your editor to update types}`);
    } catch (error) {
      logger.fatal({ error }, `failed to write type definitions file`);
    }
  }

  // see file - libs/home-assistant/src/dynamic.ts
  async function doBuild() {
    logger.info(`Pulling information`);
    const entities = await hass.fetch.getAllEntities();
    const entitySetup = {};
    entities.forEach(i => internal.utils.object.set(entitySetup, i.entity_id, i));

    try {
      logger.debug("building [ENTITY_SETUP]");
      const ENTITY_SETUP = await type_build.domain.build();
      logger.debug("building [iCallService]");
      const typeInterface = await type_build.call_service();

      return [
        `// This file is generated, and is automatically updated as a npm post install step`,
        "// Do not edit this file, it will only affect type definitions, not functional code",
        `import {`,
        `  AndroidNotificationData,`,
        `  AppleNotificationData,`,
        `  NotificationData,`,
        `  PICK_ENTITY,`,
        `  WeatherGetForecasts,`,
        `} from "./helpers";`,
        ``,
        PICK_FROM_PLATFORM,
        ``,
        `// #MARK: ENTITY_SETUP`,
        ENTITY_SETUP,
        ``,
        `// #MARK: iCallService`,
        typeInterface,
        ``,
        `// #MARK: REGISTRY_SETUP`,
        type_build.identifiers.registryDetails(),
        ``,
        `// #MARK: TAreaId`,
        type_build.identifiers.area(),
        ``,
        `// #MARK: TDeviceId`,
        type_build.identifiers.device(),
        ``,
        `// #MARK: TFloorId`,
        type_build.identifiers.floor(),
        ``,
        `// #MARK: TLabelId`,
        type_build.identifiers.label(),
        ``,
        `// #MARK: TZoneId`,
        type_build.identifiers.zone(),
        ``,
        `// #MARK: TUniqueIDMapping`,
        type_build.identifiers.uniqueIdMapping(),
        ``,
        `// #MARK: TUniqueID`,
        type_build.identifiers.uniqueId(),
        ``,
        `// #MARK: TRawEntityIds`,
        type_build.identifiers.entityIds(entities),
        ``,
        `// #MARK: TPlatformId`,
        type_build.identifiers.platforms(),
        ``,
        `// #MARK: TRawDomains`,
        type_build.identifiers.domains(entities),
      ].join(`\n`);
    } catch (error) {
      logger.error({ error }, "failed to build data, please report");
      exit();
    }
  }
  return runner;
}
